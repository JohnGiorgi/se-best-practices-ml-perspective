{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About this Resource This repository is meant to serve as an opinionated, pedagogical guide on software engineering best practices for those of us in machine learning. What is this guide NOT? It is NOT a comprehensive overview of best practices in software engineering. It is a highly opinionated sampling of tools and ideas that are important for writing good code in a machine learning project. This includes linting, formatting and testing. Who is this guide for? Machine learners who are not currently following software engineering best practices in their projects but would like to. What is machine learning specific about this guide? In truth, nothing important. We use Python as the language of choice as it is popular in machine learning, and we write some machine learning specific tests. Otherwise, this guide could apply to (almost) any python project. What tools will this guide cover? Poetry , for managing virtual enviornments and package dependencies. flake8 , for linting. black , for formatting. pytest , for testing. GitHub Actions , for continous integration / continous development (CI/CD).","title":"Home"},{"location":"#about-this-resource","text":"This repository is meant to serve as an opinionated, pedagogical guide on software engineering best practices for those of us in machine learning. What is this guide NOT? It is NOT a comprehensive overview of best practices in software engineering. It is a highly opinionated sampling of tools and ideas that are important for writing good code in a machine learning project. This includes linting, formatting and testing. Who is this guide for? Machine learners who are not currently following software engineering best practices in their projects but would like to. What is machine learning specific about this guide? In truth, nothing important. We use Python as the language of choice as it is popular in machine learning, and we write some machine learning specific tests. Otherwise, this guide could apply to (almost) any python project. What tools will this guide cover? Poetry , for managing virtual enviornments and package dependencies. flake8 , for linting. black , for formatting. pytest , for testing. GitHub Actions , for continous integration / continous development (CI/CD).","title":"About this Resource"},{"location":"getting_started/","text":"To get started, make sure you have Python 3.6.1 or newer installed.","title":"Getting Started"},{"location":"linting_and_formatting/","text":"Linting A linter is a tool that can automatically identify syntax and stylistic errors in your code. A very popular linter for python is flake8 and will be our tool of choice in this guide. First, make sure we are in our project directory (named se_best_practices_ml_perspective ) by default. Then, lets add flake8 as a development dependency. poetry add --dev flake8 --dev just means we want this to be a development dependency , that is, a dependency we need to develop our code, but not required by an end user who simply wants to run our code. Lets check our pyproject.toml . [tool.poetry] name = \"se_best_practices_ml_perspective\" version = \"0.1.0\" description = \"\" authors = [\"johngiorgi <johnmgiorgi@gmail.com>\"] [tool.poetry.dependencies] python = \"^3.7\" pytorch-lightning = \"^0.9.0\" torchvision = \"^0.7.0\" [tool.poetry.dev-dependencies] pytest = \"^5.2\" flake8 = \"^3.8.3\" [build-system] requires = [\"poetry>=0.12\"] build-backend = \"poetry.masonry.api\" As expected, flake8 has been added as a development dependency. Now, lets setup a simple example with pytorch-lightning . We will borrow their minimal example . Download it by running the following. curl -o se_best_practices_ml_perspective/main.py https://raw.githubusercontent.com/JohnGiorgi/se_best_practices_ml_perspective/master/se_best_practices_ml_perspective/main_with_stylistic_errors.py Then, lets lint the file, checking it for errors. poetry run flake8 . flake8 reports several sytlistic errors ./se_best_practices_ml_perspective/main.py:1:80: E501 line too long (90 > 79 characters) ./se_best_practices_ml_perspective/main.py:28:1: W293 blank line contains whitespace ./se_best_practices_ml_perspective/main.py:40:1: E305 expected 2 blank lines after class or function definition, found 1 ./se_best_practices_ml_perspective/main.py:41:80: E501 line too long (80 > 79 characters) ./se_best_practices_ml_perspective/main.py:46:59: W292 no newline at end of file Now, we could fix each error manually, but in the next section, we will see how a code formatter can automatically fix them for us! Code Formatting A code formatter is a tool that will ensure your code follows a particular code style. Using a consistent code style across your codebase can improve readability. Combining an automatic code formatter with a linter is a great way to improve your code style effortlessly. A very popular code formatter for python is black and will be our tool of choice in this guide. First, just like the flake8 , lets add black as a development dependency. poetry add --dev black Note We need to configure a few flake8 settings so that it plays nicely with black . Create a .flake8 file in the top level of your project with the following content. [flake8] ignore = # these rules don't play well with black E203 # whitespace before : W503 # line break before binary operator Or download it directly from this repository curl -o ./.flake8 https://raw.githubusercontent.com/JohnGiorgi/se_best_practices_ml_perspective/master/.flake8 Once installed, we can automatically format our code with the following command poetry run black . With our code reformatted, lets call the linter again poetry run flake8 . Notice that all the stylistic errors are gone! With a code formatter and a linter, we can easily and automatically improve our code style, improving consistency and readability within and between our projects. In the next section, we will go over perhaps the most important best practice, testing!","title":"Linting and Formatting"},{"location":"linting_and_formatting/#linting","text":"A linter is a tool that can automatically identify syntax and stylistic errors in your code. A very popular linter for python is flake8 and will be our tool of choice in this guide. First, make sure we are in our project directory (named se_best_practices_ml_perspective ) by default. Then, lets add flake8 as a development dependency. poetry add --dev flake8 --dev just means we want this to be a development dependency , that is, a dependency we need to develop our code, but not required by an end user who simply wants to run our code. Lets check our pyproject.toml . [tool.poetry] name = \"se_best_practices_ml_perspective\" version = \"0.1.0\" description = \"\" authors = [\"johngiorgi <johnmgiorgi@gmail.com>\"] [tool.poetry.dependencies] python = \"^3.7\" pytorch-lightning = \"^0.9.0\" torchvision = \"^0.7.0\" [tool.poetry.dev-dependencies] pytest = \"^5.2\" flake8 = \"^3.8.3\" [build-system] requires = [\"poetry>=0.12\"] build-backend = \"poetry.masonry.api\" As expected, flake8 has been added as a development dependency. Now, lets setup a simple example with pytorch-lightning . We will borrow their minimal example . Download it by running the following. curl -o se_best_practices_ml_perspective/main.py https://raw.githubusercontent.com/JohnGiorgi/se_best_practices_ml_perspective/master/se_best_practices_ml_perspective/main_with_stylistic_errors.py Then, lets lint the file, checking it for errors. poetry run flake8 . flake8 reports several sytlistic errors ./se_best_practices_ml_perspective/main.py:1:80: E501 line too long (90 > 79 characters) ./se_best_practices_ml_perspective/main.py:28:1: W293 blank line contains whitespace ./se_best_practices_ml_perspective/main.py:40:1: E305 expected 2 blank lines after class or function definition, found 1 ./se_best_practices_ml_perspective/main.py:41:80: E501 line too long (80 > 79 characters) ./se_best_practices_ml_perspective/main.py:46:59: W292 no newline at end of file Now, we could fix each error manually, but in the next section, we will see how a code formatter can automatically fix them for us!","title":"Linting"},{"location":"linting_and_formatting/#code-formatting","text":"A code formatter is a tool that will ensure your code follows a particular code style. Using a consistent code style across your codebase can improve readability. Combining an automatic code formatter with a linter is a great way to improve your code style effortlessly. A very popular code formatter for python is black and will be our tool of choice in this guide. First, just like the flake8 , lets add black as a development dependency. poetry add --dev black Note We need to configure a few flake8 settings so that it plays nicely with black . Create a .flake8 file in the top level of your project with the following content. [flake8] ignore = # these rules don't play well with black E203 # whitespace before : W503 # line break before binary operator Or download it directly from this repository curl -o ./.flake8 https://raw.githubusercontent.com/JohnGiorgi/se_best_practices_ml_perspective/master/.flake8 Once installed, we can automatically format our code with the following command poetry run black . With our code reformatted, lets call the linter again poetry run flake8 . Notice that all the stylistic errors are gone! With a code formatter and a linter, we can easily and automatically improve our code style, improving consistency and readability within and between our projects. In the next section, we will go over perhaps the most important best practice, testing!","title":"Code Formatting"},{"location":"managing_depedencies/","text":"Managing depedencies is important for any software project. In machine learning environments, it is particulary important if you care about reproducible results (and you should!). In Python, the canonical approach is to create isolated virtual enviroments for each of our projects. These virtual enviroments store the specific dependencies needed for a given project, without interferring with the dependencies of other projects Note See here for a great introduction on virtual environments. In this guide, we are going to use Poetry, both for creating virtual enviorments and for managing dependencies. Installing Poetry To install poetry, run one of the following commands, depending on your system. osx / linux / bash on windows curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python windows powershell ( Invoke-WebRequest -Uri https : // raw . githubusercontent . com / python-poetry / poetry / master / get-poetry . py -UseBasicParsing ). Content | python Creating a Python Package with Poetry With Poetry installed, we can create our first project like so poetry new se_best_practices_ml_perspective Note The reminder of the guide will assume you have called it se_best_practices_ml_perspective , but you can name it whatever you want. Notice that poetry has automatically created a project directory for us. This includes a README , a main package directory se_best_practices_ml_perspective , and a tests directory (we will return to this later). se_best_practices_ml_perspective \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.rst \u251c\u2500\u2500 se_best_practices_ml_perspective \u2502 \u2514\u2500\u2500 __init__.py \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_poetry_demo.py Most importantly, pyproject.toml is the configuration file (automatically generated by Poetry) that will contain metadata about our package (like its name, version, and a description) along with our depedencies. Besides the authors line highlited in yellow, your pyproject.toml should look like the following. [tool.poetry] name = \"se_best_practices_ml_perspective\" version = \"0.1.0\" description = \"\" authors = [\"johngiorgi <johnmgiorgi@gmail.com>\"] [tool.poetry.dependencies] python = \"^3.7\" [tool.poetry.dev-dependencies] pytest = \"^5.2\" [build-system] requires = [\"poetry>=0.12\"] build-backend = \"poetry.masonry.api\" Adding Dependencies with Poetry Adding dependencies is easy. Simply call poetry add <package_name> . For example, we will need pytorch-lightning and torchvision in this guide. poetry add pytorch-lightning torchvision Poetry will automatically create a virtual environment if one does not exist, and add pytorch-lightning and torchvision as dependencies to pyproject.toml . [tool.poetry] name = \"se_best_practices_ml_perspective\" version = \"0.1.0\" description = \"\" authors = [\"johngiorgi <johnmgiorgi@gmail.com>\"] [tool.poetry.dependencies] python = \"^3.7\" pytorch-lightning = \"^0.9.0\" torchvision = \"^0.7.0\" [tool.poetry.dev-dependencies] pytest = \"^5.2\" [build-system] requires = [\"poetry>=0.12\"] Thats it for now. In the next section, we will go over linting and formatting.","title":"Managing Dependencies"},{"location":"managing_depedencies/#installing-poetry","text":"To install poetry, run one of the following commands, depending on your system. osx / linux / bash on windows curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python windows powershell ( Invoke-WebRequest -Uri https : // raw . githubusercontent . com / python-poetry / poetry / master / get-poetry . py -UseBasicParsing ). Content | python","title":"Installing Poetry"},{"location":"managing_depedencies/#creating-a-python-package-with-poetry","text":"With Poetry installed, we can create our first project like so poetry new se_best_practices_ml_perspective Note The reminder of the guide will assume you have called it se_best_practices_ml_perspective , but you can name it whatever you want. Notice that poetry has automatically created a project directory for us. This includes a README , a main package directory se_best_practices_ml_perspective , and a tests directory (we will return to this later). se_best_practices_ml_perspective \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.rst \u251c\u2500\u2500 se_best_practices_ml_perspective \u2502 \u2514\u2500\u2500 __init__.py \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_poetry_demo.py Most importantly, pyproject.toml is the configuration file (automatically generated by Poetry) that will contain metadata about our package (like its name, version, and a description) along with our depedencies. Besides the authors line highlited in yellow, your pyproject.toml should look like the following. [tool.poetry] name = \"se_best_practices_ml_perspective\" version = \"0.1.0\" description = \"\" authors = [\"johngiorgi <johnmgiorgi@gmail.com>\"] [tool.poetry.dependencies] python = \"^3.7\" [tool.poetry.dev-dependencies] pytest = \"^5.2\" [build-system] requires = [\"poetry>=0.12\"] build-backend = \"poetry.masonry.api\"","title":"Creating a Python Package with Poetry"},{"location":"managing_depedencies/#adding-dependencies-with-poetry","text":"Adding dependencies is easy. Simply call poetry add <package_name> . For example, we will need pytorch-lightning and torchvision in this guide. poetry add pytorch-lightning torchvision Poetry will automatically create a virtual environment if one does not exist, and add pytorch-lightning and torchvision as dependencies to pyproject.toml . [tool.poetry] name = \"se_best_practices_ml_perspective\" version = \"0.1.0\" description = \"\" authors = [\"johngiorgi <johnmgiorgi@gmail.com>\"] [tool.poetry.dependencies] python = \"^3.7\" pytorch-lightning = \"^0.9.0\" torchvision = \"^0.7.0\" [tool.poetry.dev-dependencies] pytest = \"^5.2\" [build-system] requires = [\"poetry>=0.12\"] Thats it for now. In the next section, we will go over linting and formatting.","title":"Adding Dependencies with Poetry"},{"location":"testing/","text":"This is the most important section in the guide. Unit tests are short tests that assert the output of some function or method equals the expected value for some given input. They allow us to ensure our code does what we think it does, reducing bugs and making it dramatically easier to refactor our code down the line. There are multiple unit testing frameworks in Python, but we will use a very popular one, pytest . Typically, tests are grouped under a tests directory (Poetry created this for us automatically). Lets start by creating a file, test_main.py under tests . touch tests/test_main.py As is common, we will group our tests for a class under another class, like so from se_best_practices_ml_perspective.main import LitClassifier class TestLitClassifier : def test_forward ( self ): assert False def test_training_step ( self ): assert False def test_validation_step ( self ): assert False def test_configure_optimizers ( self ): assert False We start with one unit test per method of LitClassifier . A passing test must contain an assert statement that evaluates to True . To run our unit tests, we simply call poetry run pytest Notice that all four tests fail, as expected. ================================================== short test summary info ================================================== FAILED tests/test_main.py::TestLitClassifier::test_forward - assert False FAILED tests/test_main.py::TestLitClassifier::test_training_step - assert False FAILED tests/test_main.py::TestLitClassifier::test_validation_step - assert False FAILED tests/test_main.py::TestLitClassifier::test_configure_optimizers - assert False Lets get each test to pass, one-by-one, starting with test_forward . from se_best_practices_ml_perspective.main import LitClassifier import torch class TestLitClassifier : model = LitClassifier () def test_forward ( self ): \"\"\"Assert that the output shape of `LitClassifier.forward` is as expected.\"\"\" inputs = torch . randn ( 1 , 28 , 28 ) outputs = self . model . forward ( inputs ) expected_size = ( 1 , 10 ) actual_size = outputs . size () assert actual_size == expected_size def test_training_step ( self ): assert False def test_validation_step ( self ): assert False def test_configure_optimizers ( self ): assert False Here, we add a simple test that asserts for some random input, our output is of the expected shape. Running the tests again, we will notice that test_forward is now passing. ================================================== short test summary info ================================================== FAILED tests/test_main.py::TestLitClassifier::test_training_step - assert False FAILED tests/test_main.py::TestLitClassifier::test_validation_step - assert False FAILED tests/test_main.py::TestLitClassifier::test_configure_optimizers - assert False Continuing with the remaining tests from se_best_practices_ml_perspective.main import LitClassifier import torch class TestLitClassifier : model = LitClassifier () def test_forward ( self ): \"\"\"Assert that the output shape of `LitClassifier.forward` is as expected.\"\"\" inputs = torch . randn ( 1 , 28 , 28 ) outputs = self . model . forward ( inputs ) expected_size = ( 1 , 10 ) actual_size = outputs . size () assert actual_size == expected_size def test_training_step ( self ): \"\"\"Assert that `LitClassifier.training_step` returns a non-empty dictionary.\"\"\" inputs = ( torch . randn ( 1 , 28 , 28 ), torch . randint ( 10 , ( 1 ,))) results = self . model . training_step ( batch = inputs , batch_idx = 0 ) assert isinstance ( results , dict ) assert results def test_validation_step ( self ): \"\"\"Assert that `LitClassifier.validation_step` returns a non-empty dictionary.\"\"\" inputs = ( torch . randn ( 1 , 28 , 28 ), torch . randint ( 10 , ( 1 ,))) results = self . model . validation_step ( batch = inputs , batch_idx = 0 ) assert isinstance ( results , dict ) assert results def test_configure_optimizers ( self ): \"\"\"Assert that `LitClassifier.configure_optimizers` returns an Adam optimizer with the expected learning rate. \"\"\" optimizer = self . model . configure_optimizers () assert isinstance ( optimizer , torch . optim . Adam ) assert optimizer . param_groups [ 0 ][ \"lr\" ] == 0.02 In this quick overview of unit testing, we wrote simple tests for each method of our neural network classifier. We then checked that all tests are passing, increasing our confidence that our code works as expected. In the future, we we were to refactor our code, we could re-run our tests to ensure we didn't break anything. In the next and final section, we will see how to tie everything we have learned together, and automate the process of linting, formatting and testing.","title":"Testing our Code"}]}